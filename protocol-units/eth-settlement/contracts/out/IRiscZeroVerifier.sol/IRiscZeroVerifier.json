{"abi":[{"type":"function","name":"verify","inputs":[{"name":"seal","type":"bytes","internalType":"bytes"},{"name":"imageId","type":"bytes32","internalType":"bytes32"},{"name":"postStateDigest","type":"bytes32","internalType":"bytes32"},{"name":"journalDigest","type":"bytes32","internalType":"bytes32"}],"outputs":[{"name":"","type":"bool","internalType":"bool"}],"stateMutability":"view"},{"type":"function","name":"verifyIntegrity","inputs":[{"name":"receipt","type":"tuple","internalType":"struct Receipt","components":[{"name":"seal","type":"bytes","internalType":"bytes"},{"name":"claim","type":"tuple","internalType":"struct ReceiptClaim","components":[{"name":"preStateDigest","type":"bytes32","internalType":"bytes32"},{"name":"postStateDigest","type":"bytes32","internalType":"bytes32"},{"name":"exitCode","type":"tuple","internalType":"struct ExitCode","components":[{"name":"system","type":"uint8","internalType":"enum SystemExitCode"},{"name":"user","type":"uint8","internalType":"uint8"}]},{"name":"input","type":"bytes32","internalType":"bytes32"},{"name":"output","type":"bytes32","internalType":"bytes32"}]}]}],"outputs":[{"name":"","type":"bool","internalType":"bool"}],"stateMutability":"view"}],"bytecode":{"object":"0x","sourceMap":"","linkReferences":{}},"deployedBytecode":{"object":"0x","sourceMap":"","linkReferences":{}},"methodIdentifiers":{"verify(bytes,bytes32,bytes32,bytes32)":"6efef009","verifyIntegrity((bytes,(bytes32,bytes32,(uint8,uint8),bytes32,bytes32)))":"5f3af7e2"},"rawMetadata":"{\"compiler\":{\"version\":\"0.8.24+commit.e11b9ed9\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"seal\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"imageId\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"postStateDigest\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"journalDigest\",\"type\":\"bytes32\"}],\"name\":\"verify\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes\",\"name\":\"seal\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"preStateDigest\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"postStateDigest\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"enum SystemExitCode\",\"name\":\"system\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"user\",\"type\":\"uint8\"}],\"internalType\":\"struct ExitCode\",\"name\":\"exitCode\",\"type\":\"tuple\"},{\"internalType\":\"bytes32\",\"name\":\"input\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"output\",\"type\":\"bytes32\"}],\"internalType\":\"struct ReceiptClaim\",\"name\":\"claim\",\"type\":\"tuple\"}],\"internalType\":\"struct Receipt\",\"name\":\"receipt\",\"type\":\"tuple\"}],\"name\":\"verifyIntegrity\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"verify(bytes,bytes32,bytes32,bytes32)\":{\"details\":\"This method additionally ensures that the input hash is all-zeros (i.e. no committed input), the exit code is (Halted, 0), and there are no assumptions (i.e. the receipt is unconditional).\",\"params\":{\"imageId\":\"The identifier for the guest program.\",\"journalDigest\":\"The SHA-256 digest of the journal bytes.\",\"postStateDigest\":\"A hash of the final memory state. Required to run the verifier, but     otherwise can be left unconstrained for most use cases.\",\"seal\":\"The encoded cryptographic proof (i.e. SNARK).\"},\"returns\":{\"_0\":\"true if the receipt passes the verification checks. The return code must be checked.\"}},\"verifyIntegrity((bytes,(bytes32,bytes32,(uint8,uint8),bytes32,bytes32)))\":{\"params\":{\"receipt\":\"The receipt to be verified.\"},\"returns\":{\"_0\":\"true if the receipt passes the verification checks. The return code must be checked.\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"verify(bytes,bytes32,bytes32,bytes32)\":{\"notice\":\"Verify that the given seal is a valid RISC Zero proof of execution with the     given image ID, post-state digest, and journal digest.\"},\"verifyIntegrity((bytes,(bytes32,bytes32,(uint8,uint8),bytes32,bytes32)))\":{\"notice\":\"Verify that the given receipt is a valid RISC Zero receipt, ensuring the `seal` is valid a cryptographic proof of the execution with the given `claim`.\"}},\"notice\":\"Verifier interface for RISC Zero receipts of execution.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"src/IRiscZeroVerifier.sol\":\"IRiscZeroVerifier\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[\":@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/\",\":ds-test/=lib/forge-std/lib/ds-test/src/\",\":erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\":forge-std/=lib/forge-std/src/\",\":openzeppelin-contracts/=lib/openzeppelin-contracts/\",\":openzeppelin/=lib/openzeppelin-contracts/\"]},\"sources\":{\"src/IRiscZeroVerifier.sol\":{\"keccak256\":\"0x4181470ca6e655644b30f0657b2d03ddd51bfb7566a9b69c73bb5f2654f97962\",\"license\":\"Apache-2.0\",\"urls\":[\"bzz-raw://88c14c1ebc46202e3337be2bb570cf77cd0b0951fd522e0c11c2f75e8d8534f2\",\"dweb:/ipfs/QmVw3DG5EhVAKNUs4fQW6W4r7nRuaJbNYVVaiHRVUQCF6Z\"]}},\"version\":1}","metadata":{"compiler":{"version":"0.8.24+commit.e11b9ed9"},"language":"Solidity","output":{"abi":[{"inputs":[{"internalType":"bytes","name":"seal","type":"bytes"},{"internalType":"bytes32","name":"imageId","type":"bytes32"},{"internalType":"bytes32","name":"postStateDigest","type":"bytes32"},{"internalType":"bytes32","name":"journalDigest","type":"bytes32"}],"stateMutability":"view","type":"function","name":"verify","outputs":[{"internalType":"bool","name":"","type":"bool"}]},{"inputs":[{"internalType":"struct Receipt","name":"receipt","type":"tuple","components":[{"internalType":"bytes","name":"seal","type":"bytes"},{"internalType":"struct ReceiptClaim","name":"claim","type":"tuple","components":[{"internalType":"bytes32","name":"preStateDigest","type":"bytes32"},{"internalType":"bytes32","name":"postStateDigest","type":"bytes32"},{"internalType":"struct ExitCode","name":"exitCode","type":"tuple","components":[{"internalType":"enum SystemExitCode","name":"system","type":"uint8"},{"internalType":"uint8","name":"user","type":"uint8"}]},{"internalType":"bytes32","name":"input","type":"bytes32"},{"internalType":"bytes32","name":"output","type":"bytes32"}]}]}],"stateMutability":"view","type":"function","name":"verifyIntegrity","outputs":[{"internalType":"bool","name":"","type":"bool"}]}],"devdoc":{"kind":"dev","methods":{"verify(bytes,bytes32,bytes32,bytes32)":{"details":"This method additionally ensures that the input hash is all-zeros (i.e. no committed input), the exit code is (Halted, 0), and there are no assumptions (i.e. the receipt is unconditional).","params":{"imageId":"The identifier for the guest program.","journalDigest":"The SHA-256 digest of the journal bytes.","postStateDigest":"A hash of the final memory state. Required to run the verifier, but     otherwise can be left unconstrained for most use cases.","seal":"The encoded cryptographic proof (i.e. SNARK)."},"returns":{"_0":"true if the receipt passes the verification checks. The return code must be checked."}},"verifyIntegrity((bytes,(bytes32,bytes32,(uint8,uint8),bytes32,bytes32)))":{"params":{"receipt":"The receipt to be verified."},"returns":{"_0":"true if the receipt passes the verification checks. The return code must be checked."}}},"version":1},"userdoc":{"kind":"user","methods":{"verify(bytes,bytes32,bytes32,bytes32)":{"notice":"Verify that the given seal is a valid RISC Zero proof of execution with the     given image ID, post-state digest, and journal digest."},"verifyIntegrity((bytes,(bytes32,bytes32,(uint8,uint8),bytes32,bytes32)))":{"notice":"Verify that the given receipt is a valid RISC Zero receipt, ensuring the `seal` is valid a cryptographic proof of the execution with the given `claim`."}},"version":1}},"settings":{"remappings":["@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/","ds-test/=lib/forge-std/lib/ds-test/src/","erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/","forge-std/=lib/forge-std/src/","openzeppelin-contracts/=lib/openzeppelin-contracts/","openzeppelin/=lib/openzeppelin-contracts/"],"optimizer":{"enabled":true,"runs":200},"metadata":{"bytecodeHash":"ipfs"},"compilationTarget":{"src/IRiscZeroVerifier.sol":"IRiscZeroVerifier"},"evmVersion":"paris","libraries":{}},"sources":{"src/IRiscZeroVerifier.sol":{"keccak256":"0x4181470ca6e655644b30f0657b2d03ddd51bfb7566a9b69c73bb5f2654f97962","urls":["bzz-raw://88c14c1ebc46202e3337be2bb570cf77cd0b0951fd522e0c11c2f75e8d8534f2","dweb:/ipfs/QmVw3DG5EhVAKNUs4fQW6W4r7nRuaJbNYVVaiHRVUQCF6Z"],"license":"Apache-2.0"}},"version":1},"id":26}